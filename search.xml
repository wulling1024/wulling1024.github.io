<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VS Code + Markdown 自定义文件头信息</title>
      <link href="/2021/02/08/202102/vs-code-markdown-zi-ding-yi-wen-jian-tou-xin-xi/"/>
      <url>/2021/02/08/202102/vs-code-markdown-zi-ding-yi-wen-jian-tou-xin-xi/</url>
      
        <content type="html"><![CDATA[<p>Visual Studio Code 默认是关闭了 Markdown 的智能感知提示的（因为真的是不好用，尤其是其没有中文分词的情况下）。那么在没有智能感知提示的情况下如何快速插入代码片段呢？</p><p>解决方案：<strong>自定义快捷键</strong></p><h4 id="1、打开快捷键的设置"><a href="#1、打开快捷键的设置" class="headerlink" title="1、打开快捷键的设置"></a>1、打开快捷键的设置</h4><h4 id="2、自定义如下代码片段"><a href="#2、自定义如下代码片段" class="headerlink" title="2、自定义如下代码片段"></a>2、自定义如下代码片段</h4><pre><code>{    &quot;key&quot;: &quot;alt+h&quot;,    &quot;command&quot;: &quot;editor.action.insertSnippet&quot;,    &quot;when&quot;: &quot;editorTextFocus&quot;,    &quot;args&quot;: {        &quot;langId&quot;: &quot;markdown&quot;,        &quot;name&quot;: &quot;Hexo file header&quot;    }  }</code></pre><ul><li>“langId”：文件类型信息</li><li>“name”：自定义代码片段的名称</li></ul><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p><img src="https://cdn.jsdelivr.net/gh/wulling1024/Picture-bed@master/img202102/20210208152716.gif" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC的实现机制</title>
      <link href="/2020/02/15/202002/shi-wu-zhong-mvcc-de-shi-xian-ji-zhi/"/>
      <url>/2020/02/15/202002/shi-wu-zhong-mvcc-de-shi-xian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.yuque.com/chenjiayang/blog/dozcqo?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=698513204539576320" target="_blank" rel="noopener">https://www.yuque.com/chenjiayang/blog/dozcqo?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=698513204539576320</a></p></blockquote><h3 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h3><p><code>MVCC (Multiversion Concurrency Control)</code> 中文全程叫<strong>多版本并发控制</strong>，是现代数据库（包括 <code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code> 等）引擎实现中常用的处理读写冲突的手段，<strong>目的在于提高数据库高并发场景下的吞吐性能</strong>。</p><p>如此一来不同的事务在并发过程中，<code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。</p><p>下面举一个多版本读的例子，例如两个事务 <code>A</code> 和 <code>B</code> 按照如下顺序进行更新和读取操作</p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111707.png" alt></p><p>在事务 <code>A</code> 提交前后，事务 <code>B</code> 读取到的 <code>x</code> 的值是什么呢？答案是：事务 <code>B</code> 在不同的隔离级别下，读取到的值不一样。</p><ol><li>如果事务 <code>B</code> 的隔离级别是读未提交（RU），那么两次读取均读取到 <code>x</code> 的最新值，即 <code>20</code>。</li><li>如果事务 <code>B</code> 的隔离级别是读已提交（RC），那么第一次读取到旧值 <code>10</code>，第二次因为事务 <code>A</code> 已经提交，则读取到新值 20。</li><li>如果事务 <code>B</code> 的隔离级别是可重复读或者串行（RR，S），则两次均读到旧值 <code>10</code>，不论事务 <code>A</code> 是否已经提交。</li></ol><p>可见在不同的隔离级别下，数据库通过 <code>MVCC</code> 和隔离级别，让事务之间并行操作遵循了某种规则，来<strong>保证单个事务内前后数据的一致性</strong>。</p><h3 id="为什么需要-MVCC"><a href="#为什么需要-MVCC" class="headerlink" title="为什么需要 MVCC"></a>为什么需要 MVCC</h3><p><code>InnoDB</code> 相比 <code>MyISAM</code> 有两大特点，一是支持事务，二是支持行级锁，同时事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户访问。但并发事务处理也会带来一些问题，主要包括以下几种情况：</p><ol><li><strong>更新丢失</strong>（<code>Lost Update</code>）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。</li><li><strong>脏读</strong>（<code>Dirty Reads</code>）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 <strong>“脏读”</strong>。</li><li><strong>不可重复读</strong>（<code>Non-Repeatable Reads</code>）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li><strong>幻读</strong>（<code>Phantom Reads</code>）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 <strong>“幻读”</strong>。</li></ol><p>以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供事务间的隔离机制来解决。实现隔离机制的方法主要有两种：</p><ol><li>加读写锁</li><li>一致性快照读，即 <code>MVCC</code></li></ol><p>但本质上，隔离级别是一种在并发性能和并发产生的副作用间的妥协，通常数据库均倾向于采用 <code>Weak Isolation</code>。</p><h3 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h3><p>本文聚焦于 <code>MySQL</code> 中的 <code>MVCC</code> 实现，从 <code>《高性能 MySQL》</code>一书中对 <code>MVCC</code> 的介绍可知：</p><ol><li><code>MySQL</code> 中 <code>InnoDB</code> 引擎支持 <code>MVCC</code></li><li>应对高并发事务, <code>MVCC</code> 比单纯的加行锁更有效, 开销更小</li><li><code>MVCC</code> 在读已提交<code>（Read Committed）</code>和可重复读<code>（Repeatable Read）</code>隔离级别下起作用</li><li><code>MVCC</code> 既可以基于<strong>乐观锁</strong>又可以基于<strong>悲观锁</strong>来实现</li></ol><h3 id="InnoDB-MVCC-实现原理"><a href="#InnoDB-MVCC-实现原理" class="headerlink" title="InnoDB MVCC 实现原理"></a>InnoDB MVCC 实现原理</h3><p><code>InnoDB</code> 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列：<code>DATA_TRX_ID</code>、<code>DATA_ROLL_PTR</code>（如果没有主键，则还会多一个隐藏的主键列）。</p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111754.png" alt></p><h4 id="DATA-TRX-ID"><a href="#DATA-TRX-ID" class="headerlink" title="DATA_TRX_ID"></a>DATA_TRX_ID</h4><p>记录<strong>最近更新这条行记录</strong>的<code>事务 ID</code>，大小为 <code>6</code> 个字节</p><h4 id="DATA-ROLL-PTR"><a href="#DATA-ROLL-PTR" class="headerlink" title="DATA_ROLL_PTR"></a>DATA_ROLL_PTR</h4><p>表示指向该行回滚段<code>（rollback segment）</code>的指针，大小为 <code>7</code> 个字节，<code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</p><h4 id="DB-ROW-ID"><a href="#DB-ROW-ID" class="headerlink" title="DB_ROW_ID"></a>DB_ROW_ID</h4><p>行标识（隐藏单调自增 <code>ID</code>），大小为 <code>6</code> 字节，如果表没有主键，<code>InnoDB</code> 会自动生成一个隐藏主键，因此会出现这个列。另外，每条记录的头信息（<code>record header</code>）里都有一个专门的 <code>bit</code>（<code>deleted_flag</code>）来表示当前记录是否已经被删除。</p><h3 id="如何组织-Undo-Log-链"><a href="#如何组织-Undo-Log-链" class="headerlink" title="如何组织 Undo Log 链"></a>如何组织 Undo Log 链</h3><blockquote><p>关于 Redo Log 和 Undo Log 的相关概念可见之前的文章 <a href="https://chenjiayang.me/2019/04/13/mysql-innodb-redo-undo/" target="_blank" rel="noopener">InnoDB 中的 redo 和 undo log</a></p></blockquote><p>上文提到，在多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，然后通过回滚指针组织成一条 <code>Undo Log</code> 链，这节我们通过一个简单的例子来看一下 <code>Undo Log</code> 链是如何组织的，<code>DATA_TRX_ID</code> 和 <code>DATA_ROLL_PTR</code> 两个参数在其中又起到什么样的作用。</p><p>还是以上文 <code>MVCC</code> 的例子，事务 <code>A</code> 对值 <code>x</code> 进行更新之后，该行即产生一个新版本和旧版本。假设之前插入该行的事务 <code>ID</code> 为 <code>100</code>，事务 <code>A</code> 的 <code>ID</code> 为 <code>200</code>，该行的隐藏主键为 <code>1</code>。</p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111814.png" alt></p><p>事务 <code>A</code> 的操作过程为：</p><ol><li>对 <code>DB_ROW_ID = 1</code> 的这行记录加<strong>排他锁</strong></li><li>把该行原本的值拷贝到 <code>undo log</code> 中，<code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code> 都不动</li><li>修改该行的值这时产生一个新版本，更新 <code>DATA_TRX_ID</code> 为修改记录的事务 <code>ID</code>，将 <code>DATA_ROLL_PTR</code> 指向刚刚拷贝到 <code>undo log</code> 链中的旧版本记录，这样就能通过 <code>DB_ROLL_PTR</code> 找到这条记录的历史版本。如果对同一行记录执行连续的 <code>UPDATE</code>，<code>Undo Log</code> 会组成一个链表，遍历这个链表可以看到这条记录的变迁</li><li>记录 <code>redo log</code>，包括 <code>undo log</code> 中的修改</li></ol><p>那么 <code>INSERT</code> 和 <code>DELETE</code> 会怎么做呢？其实相比 <code>UPDATE</code> 这二者很简单，<code>INSERT</code> 会产生一条新纪录，它的 <code>DATA_TRX_ID</code> 为当前插入记录的事务 <code>ID</code>；<code>DELETE</code> 某条记录时可看成是一种特殊的 <code>UPDATE</code>，其实是软删，真正执行删除操作会在 <code>commit</code> 时，<code>DATA_TRX_ID</code> 则记录下删除该记录的事务 <code>ID</code>。</p><h3 id="如何实现一致性读-——-ReadView"><a href="#如何实现一致性读-——-ReadView" class="headerlink" title="如何实现一致性读 —— ReadView"></a>如何实现一致性读 —— ReadView</h3><p>在 <code>RU</code> 隔离级别下，直接读取版本的最新记录就 OK，对于 <code>SERIALIZABLE</code> 隔离级别，则是通过加锁互斥来访问数据，因此不需要 <code>MVCC</code> 的帮助。因此 <code>MVCC</code> 运行在 <code>RC</code> 和 <code>RR</code> 这两个隔离级别下，当 <code>InnoDB</code> 隔离级别设置为二者其一时，在 <code>SELECT</code> 数据时就会用到版本链</p><blockquote><p>核心问题是版本链中哪些版本对当前事务可见？</p></blockquote><p><code>InnoDB</code> 为了解决这个问题，设计了 <code>ReadView</code>（可读视图）的概念。</p><h4 id="RR-下的-ReadView-生成"><a href="#RR-下的-ReadView-生成" class="headerlink" title="RR 下的 ReadView 生成"></a>RR 下的 ReadView 生成</h4><p>在 <code>RR</code> 隔离级别下，每个事务 <code>touch first read</code> 时（本质上就是执行<strong>第一个 <code>SELECT</code> 语句</strong>时，后续所有的 <code>SELECT</code> 都是复用这个 <code>ReadView</code>，其它 <code>update</code>, <code>delete</code>, <code>insert</code> 语句和一致性读 <code>snapshot</code> 的建立没有关系），会将<strong>当前系统中的所有的活跃事务</strong>拷贝到一个列表生成<code>ReadView</code>。</p><p>下图中事务 <code>A</code> 第一条 <code>SELECT</code> 语句在事务 <code>B</code> 更新数据前，因此生成的 <code>ReadView</code> 在事务 <code>A</code> 过程中不发生变化，即使事务 <code>B</code> 在事务 <code>A</code> 之前提交，但是事务 <code>A</code> 第二条查询语句依旧无法读到事务 <code>B</code> 的修改。</p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111845.png" alt></p><p>下图中，事务 <code>A</code> 的第一条 <code>SELECT</code> 语句在事务 <code>B</code> 的修改提交之后，因此可以读到事务 <code>B</code> 的修改。<strong>但是注意，如果事务 <code>A</code> 的第一条 <code>SELECT</code> 语句查询时，事务 <code>B</code> 还未提交，那么事务 <code>A</code> 也查不到事务 <code>B</code> 的修改。</strong></p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111909.png" alt></p><h4 id="RC-下的-ReadView-生成"><a href="#RC-下的-ReadView-生成" class="headerlink" title="RC 下的 ReadView 生成"></a>RC 下的 ReadView 生成</h4><p>在 <code>RC</code> 隔离级别下，<strong>每个 <code>SELECT</code> 语句开始时</strong>，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code>。二者的区别就在于生成 <code>ReadView</code> 的时间点不同，一个是事务之后第一个 <code>SELECT</code> 语句开始、一个是事务中每条 <code>SELECT</code> 语句开始。</p><p><code>ReadView</code> 中是当前活跃的事务 <code>ID</code> 列表，称之为 <code>m_ids</code>，其中最小值为 <code>up_limit_id</code>，最大值为 <code>low_limit_id</code>，事务 <code>ID</code> 是事务开启时 <code>InnoDB</code> 分配的，其大小决定了事务开启的先后顺序，因此我们可以通过 <code>ID</code> 的大小关系来决定版本记录的可见性，具体判断流程如下：</p><ol><li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值 <code>up_limit_id</code>，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值 <code>low_limit_id</code>，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li><li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li><li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code>，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li></ol><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111928.png" alt></p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><h4 id="RC-下的-MVCC-判断流程"><a href="#RC-下的-MVCC-判断流程" class="headerlink" title="RC 下的 MVCC 判断流程"></a>RC 下的 MVCC 判断流程</h4><p>我们现在回看刚刚的查询过程，为什么事务 <code>B</code> 在 <code>RC</code> 隔离级别下，两次查询的 <code>x</code> 值不同。<code>RC</code> 下 <code>ReadView</code> 是在语句粒度上生成的。</p><p>当事务 <code>A</code> 未提交时，事务 <code>B</code> 进行查询，假设事务 <code>B</code> 的事务 <code>ID</code> 为 <code>300</code>，此时生成 <code>ReadView</code> 的 <code>m_ids</code> 为 [200，300]，而最新版本的 <code>trx_id</code> 为 <code>200</code>，处于 <code>m_ids</code> 中，则该版本记录不可被访问，查询版本链得到上一条记录的 trx_id 为 <code>100</code>，小于 <code>m_ids</code> 的最小值 <code>200</code>，因此可以被访问，此时事务 <code>B</code> 就查询到值 <code>10</code> 而非 <code>20</code>。</p><p>待事务 <code>A</code> 提交之后，事务 <code>B</code> 进行查询，此时生成的 <code>ReadView</code> 的 <code>m_ids</code> 为 [300]，而最新的版本记录中 <code>trx_id</code> 为 <code>200</code>，小于 <code>m_ids</code> 的最小值 <code>300</code>，因此可以被访问到，此时事务 <code>B</code> 就查询到 <code>20</code>。</p><h4 id="RR-下的-MVCC-判断流程"><a href="#RR-下的-MVCC-判断流程" class="headerlink" title="RR 下的 MVCC 判断流程"></a>RR 下的 MVCC 判断流程</h4><p>如果在 <code>RR</code> 隔离级别下，为什么事务 <code>B</code> 前后两次均查询到 <code>10</code> 呢？<code>RR</code> 下生成 <code>ReadView</code> 是在事务开始时，m_ids 为 [200,300]，后面不发生变化，因此即使事务 <code>A</code> 提交了，<code>trx_id</code> 为 <code>200</code> 的记录依旧处于 <code>m_ids</code> 中，不能被访问，只能访问版本链中的记录 <code>10</code>。</p><h4 id="一个争论点"><a href="#一个争论点" class="headerlink" title="一个争论点"></a>一个争论点</h4><p>其实并非所有的情况都能套用 <code>MVCC</code> 读的判断流程，<strong>特别是针对在事务进行过程中，另一个事务已经提交修改的情况下</strong>，这时不论是 <code>RC</code> 还是 <code>RR</code>，直接套用 <code>MVCC</code> 判断都会有问题，例如 <code>RC</code> 下：</p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516111959.png" alt></p><p>事务 <code>A</code> 的 <code>trx_id = 200</code>，事务 <code>B</code> 的 <code>trx_id = 300</code>，且事务 <code>B</code> 修改了数据之后在事务 <code>A</code> 之前提交，此时 <code>RC</code> 下事务 <code>A</code> 读到的数据为事务 <code>B</code> 修改后的值，这是很显然的。下面我们套用下 <code>MVCC</code> 的判断流程，考虑到事务 <code>A</code> 第二次 <code>SELECT</code> 时，<code>m_ids</code> 应该为 [200]，此时该行数据最新的版本 <code>DATA_TRX_ID = 300</code> 比 <code>200</code> 大，照理应该不能被访问，但实际上事务 <code>A</code> 选取了这条记录返回。</p><p>这里其实应该结合 <code>RC</code> 的本质来看，<code>RC</code> 的本质就是事务中每一条 <code>SELECT</code> 语句均可以看到其他已提交事务对数据的修改，那么只要该事物已经提交其结果就是可见的，与这两个事务开始的先后顺序无关，<strong>不完全适用于 MVCC 读</strong>。</p><p><code>RR</code> 级别下还是用之前那张图：</p><p><img src="https://gitee.com/wulling1024/Picture-bed/raw/master/img/20200516112015.png" alt></p><p>这张图的流程中，事务 <code>B</code> 的 <code>trx_id = 300</code> 比事务 <code>A</code> <code>200</code> 小，且事务 <code>B</code> 先于事务 <code>A</code> 提交，按照 <code>MVCC</code> 的判断流程，事务 <code>A</code> 生成的 <code>ReadView</code> 为 [200]，最新版本的行记录 <code>DATA_TRX_ID = 300</code> 比 <code>200</code> 大，照理不能访问到，但是事务 <code>A</code> 实际上读到了事务 <code>B</code> 已经提交的修改。这里还是结合 <code>RR</code> 本质进行解释，<code>RR</code> 的本质是从第一个 <code>SELECT</code> 语句生成 <code>ReadView</code> 开始，任何已经提交过的事务的修改均可见。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>RC</code>、<code>RR</code> 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。<code>RC</code>、<code>RR</code> 这两个隔离级别的一个很大不同就是生成 <code>ReadView</code> 的时间点不同，<code>RC</code> 在每一次 <code>SELECT</code> 语句前都会生成一个 <code>ReadView</code>，事务期间会更新，因此在其他事务提交前后所得到的 <code>m_ids</code> 列表可能发生变化，使得先前不可见的版本后续又突然可见了。而 <code>RR</code> 只在事务的第一个 <code>SELECT</code> 语句时生成一个 <code>ReadView</code>，事务操作期间不更新。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> InnoDB </tag>
            
            <tag> Transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell中提示无法执行Script</title>
      <link href="/2020/02/10/202002/powershell-de-zhi-xing-ce-lue/"/>
      <url>/2020/02/10/202002/powershell-de-zhi-xing-ce-lue/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/wulling1024/Picture-bed@master/img202005/20200508220730.png" alt></p><blockquote><p>PowerShell’s execution policy is a safety feature that controls the conditions under which PowerShell loads configuration files and runs scripts. This feature helps prevent the execution of malicious scripts.</p></blockquote><p><strong>解决方案：</strong></p><p>1、要获得当前PowerShell会话的有效执行策略</p><pre class="line-numbers language-powershell"><code class="language-powershell">Get<span class="token operator">-</span>ExecutionPolicy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取所有影响当前会话的执行策略，并按优先顺序显示它们</p><pre class="line-numbers language-powershell"><code class="language-powershell">Get<span class="token operator">-</span>ExecutionPolicy <span class="token operator">-</span>List<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、更改执行策略</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Set-ExecutionPolicy -ExecutionPolicy &lt;PolicyName> -Scope &lt;scope></span><span class="token function">Set</span><span class="token operator">-</span>ExecutionPolicy <span class="token operator">-</span>ExecutionPolicy RemoteSigned <span class="token operator">-</span>Scope CurrentUser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="PowerShell-execution-policies"><a href="#PowerShell-execution-policies" class="headerlink" title="PowerShell execution policies"></a>PowerShell execution policies</h2><p>这些策略只在Windows平台上执行。PowerShell具体执行策略如下：</p><h3 id="AllSigned"><a href="#AllSigned" class="headerlink" title="AllSigned"></a>AllSigned</h3><ul><li>Scripts can run.</li><li>Requires that all scripts and configuration files be signed by a trusted publisher, including scripts that you write on the local computer.</li><li>Prompts you before running scripts from publishers that you haven’t yet classified as trusted or untrusted.</li><li>Risks running signed, but malicious, scripts.</li></ul><h3 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h3><ul><li>Nothing is blocked and there are no warnings or prompts.</li><li>This execution policy is designed for configurations in which a PowerShell script is built in to a larger application or for configurations in which PowerShell is the foundation for a program that has its own security model.</li></ul><h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><ul><li>Sets the default execution policy.</li><li><strong>Restricted</strong> for Windows clients.</li><li><strong>RemoteSigned</strong> for Windows servers.</li></ul><h3 id="RemoteSigned"><a href="#RemoteSigned" class="headerlink" title="RemoteSigned"></a>RemoteSigned</h3><ul><li>The default execution policy for Windows server computers.</li><li>Scripts can run.</li><li>Requires a digital signature from a trusted publisher on scripts and configuration files that are downloaded from the internet which includes email and instant messaging programs.</li><li>Doesn’t require digital signatures on scripts that are written on the local computer and not downloaded from the internet.</li><li>Runs scripts that are downloaded from the internet and not signed, if the scripts are unblocked, such as by using the cmdlet.<code>Unblock-File</code></li><li>Risks running unsigned scripts from sources other than the internet and signed scripts that could be malicious.</li></ul><h3 id="Restricted"><a href="#Restricted" class="headerlink" title="Restricted"></a>Restricted</h3><ul><li>The default execution policy for Windows client computers.</li><li>Permits individual commands, but does not allow scripts.</li><li>Prevents running of all script files, including formatting and configuration files ()<code>.ps1xml</code>, module script files ()<code>.psm1</code>, and PowerShell profiles ()<code>.ps1</code>.</li></ul><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><ul><li>There is no execution policy set in the current scope.</li><li>If the execution policy in all scopes is <strong>Undefined</strong>, the effective execution policy is <strong>Restricted</strong>, which is the default execution policy.</li></ul><h3 id="Unrestricted"><a href="#Unrestricted" class="headerlink" title="Unrestricted"></a>Unrestricted</h3><ul><li>The default execution policy for non-Windows computers and cannot be changed.</li><li>Unsigned scripts can run. There is a risk of running malicious scripts.</li><li>Warns the user before running scripts and configuration files that are not from the local intranet zone.</li></ul><h2 id="Execution-policy-scope"><a href="#Execution-policy-scope" class="headerlink" title="Execution policy scope"></a>Execution policy scope</h2><p>设置仅在特定范围内有效的执行策略</p><p>范围值按优先顺序列出。优先级更高的策略在当前会话中有效，即使更严格的策略被设置为优先级更低的策略。</p><h3 id="MachinePolicy"><a href="#MachinePolicy" class="headerlink" title="MachinePolicy"></a>MachinePolicy</h3><p>Set by a Group Policy for all users of the computer.</p><h3 id="UserPolicy"><a href="#UserPolicy" class="headerlink" title="UserPolicy"></a>UserPolicy</h3><p>Set by a Group Policy for the current user of the computer.</p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>The <strong>Process</strong> scope only affects the current PowerShell session. The execution policy is saved in the environment variable , rather than the registry. When the PowerShell session is closed, the variable and value are deleted.<code>$env:PSExecutionPolicyPreference</code></p><h3 id="CurrentUser"><a href="#CurrentUser" class="headerlink" title="CurrentUser"></a>CurrentUser</h3><p>The execution policy affects only the current user. It’s stored in the <strong>HKEY_CURRENT_USER</strong> registry subkey.</p><h3 id="LocalMachine"><a href="#LocalMachine" class="headerlink" title="LocalMachine"></a>LocalMachine</h3><p>The execution policy affects all users on the current computer. It’s stored in the <strong>HKEY_LOCAL_MACHINE</strong> registry subkey.</p><blockquote><p>参考：<a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2报错：参考对象类型不支持尝试的操作</title>
      <link href="/2020/02/08/202002/wsl2-bao-cuo-can-kao-dui-xiang-lei-xing-bu-zhi-chi/"/>
      <url>/2020/02/08/202002/wsl2-bao-cuo-can-kao-dui-xiang-lei-xing-bu-zhi-chi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：Ryan（版权属于）</p><p>本文链接：<a href="https://kkp.disk.st/4608.html" target="_blank" rel="noopener">https://kkp.disk.st/4608.html</a></p></blockquote><p>突然发现WSL无法使用，Ubuntu无法启动</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token function">PS</span> C:\WINDOWS\system32> wsl<span class="token punctuation">.</span>exe <span class="token operator">--</span>shutdown<span class="token function">PS</span> C:\WINDOWS\system32> wsl<span class="token punctuation">.</span>exeThe attempted operation is not supported <span class="token keyword">for</span> the <span class="token function">type</span> of object referenced<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据<a href="https://github.com/microsoft/WSL2-Linux-Kernel/issues?page=1&q=is%3Aissue+is%3Aopen" target="_blank" rel="noopener">Github issue</a>可知是WSL2目前不兼容VPN类应用（我安装了EasyConnect），复位 <strong>winsock</strong> 配置并重启计算机就可以了</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token function">PS</span> C:\WINDOWS\system32> netsh winsock resetSucessfully reset the Winsock Catalog<span class="token punctuation">.</span>You must restart the computer in order to complete the reset<span class="token punctuation">.</span><span class="token function">PS</span> C:\WINDOWS\system32> wsl<span class="token punctuation">.</span>exeroot@TIGERHOMEPC <span class="token operator">/</span>mnt<span class="token operator">/</span>c<span class="token operator">/</span>Windows<span class="token operator">/</span>System32<span class="token comment" spellcheck="true"># exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的事务</title>
      <link href="/2020/02/06/202002/spring-zhong-shi-yong-shi-wu-transaction/"/>
      <url>/2020/02/06/202002/spring-zhong-shi-yong-shi-wu-transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h1><h2 id="1、事务管理机制"><a href="#1、事务管理机制" class="headerlink" title="1、事务管理机制"></a>1、事务管理机制</h2><p>事务管理在系统开发中是不可缺少的一部分，<code>Spring</code>提供了很好事务管理机制，主要分为<code>编程式事务</code>和<code>声明式事务</code>两种。</p><p><strong>编程式事务</strong>：是指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强，如下示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//TODO something</span>     transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvoiceApplyException</span><span class="token punctuation">(</span><span class="token string">"异常失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>声明式事务</strong>：基于<code>AOP</code>面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，一是基于<code>TX</code>和<code>AOP</code>的 xml 配置文件方式，二种就是基于@Transactional 注解了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> insert <span class="token operator">=</span> cityInfoDictMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cityInfoDict<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、-Transaction-的作用范围"><a href="#2、-Transaction-的作用范围" class="headerlink" title="2、@Transaction 的作用范围"></a>2、@Transaction 的作用范围</h2><ul><li><strong>作用于类</strong>：当把 @Transactional 注解放在类上时，表示所有该类的<code>public</code>方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了 @Transactional，<em>方法的事务会覆盖类的事务配置信息</em>。</li><li><strong>作用于接口</strong>：不推荐这种使用方法，因为一旦标注在Interface上并且配置了 Spring AOP 使用 CGLib 动态代理，将会导致 @Transactional 注解失效</li></ul><pre class="line-numbers language-java"><code class="language-java"> <span class="token annotation punctuation">@Transactional</span> <span class="token annotation punctuation">@RestController</span> <span class="token annotation punctuation">@RequestMapping</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisPlusController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> CityInfoDictMapper cityInfoDictMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        CityInfoDict cityInfoDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CityInfoDict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setParentCityId</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setCityName</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setCityLevel</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setCityCode</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> insert <span class="token operator">=</span> cityInfoDictMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cityInfoDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> insert <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、-Transaction-的参数介绍"><a href="#3、-Transaction-的参数介绍" class="headerlink" title="3、@Transaction 的参数介绍"></a>3、@Transaction 的参数介绍</h2><ul><li><p><strong>propagation</strong> 属性：</p><p><code>propagation</code> 代表事务的 <strong>传播行为</strong>，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><p><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。</p><blockquote><p><strong>(</strong> 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></p></blockquote></li><li><p><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</p></li><li><p><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</p></li><li><p><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</p><blockquote><p><strong>(</strong> 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></p></blockquote></li><li><p><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</p></li><li><p><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</p></li><li><p><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</p></li></ul></li><li><p><strong>isolation</strong> 属性：</p><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul></li><li><p><strong>timeout</strong> 属性：</p><p>事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p></li><li><p><strong>readOnly</strong> 属性：</p><p>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p></li><li><p><strong>rollbackFor</strong> 属性：</p><p>用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p></li><li><p><strong>noRollbackFor</strong> 属性：</p><p>抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后台框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transaction </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题使用介绍</title>
      <link href="/2020/02/02/202002/hello-world/"/>
      <url>/2020/02/02/202002/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo模板 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
